<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Red Balloon Blaster - Evolved</title>
    <style>
        /* --- CSS Styling --- */
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            color: #eee;
            overflow: hidden; /* Prevent scrollbars */
            -webkit-user-select: none; /* Disable text selection for better game feel */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation; /* Allow taps to pass through, but prevent double tap zoom */
        }

        #game-container {
            width: 80vw;
            max-width: 800px; /* Max width for larger screens */
            height: 90vh;
            max-height: 700px; /* Max height */
            border: 5px solid #888;
            background-color: #333;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
        }

        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            text-align: center;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        /* Start Screen */
        #start-screen input {
            padding: 10px;
            margin-bottom: 20px;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            width: 60%;
            max-width: 300px;
            color: #333;
        }

        #start-screen button,
        #pause-screen button,
        #level-complete-screen button,
        #game-over-screen button {
            padding: 10px 20px;
            margin: 10px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        #start-screen button:hover,
        #pause-screen button:hover,
        #level-complete-screen button:hover,
        #game-over-screen button:hover {
            background-color: #0056b3;
        }

        /* Game Play Screen */
        #game-play-screen {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: stretch;
            padding: 10px;
            box-sizing: border-box;
            background-color: #444;
        }

        #game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            font-size: 1.1em;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #game-area {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: #666;
            border-radius: 5px;
            cursor: pointer; /* Indicates it's clickable */
            touch-action: none; /* Prevent browser touch actions like scrolling/zooming */
        }

        #cannon {
            position: absolute;
            bottom: 5px;
            width: 60px;
            height: 40px;
            background-color: #8B4513;
            border-radius: 10px 10px 0 0;
            left: calc(50% - 30px);
            cursor: grab;
            z-index: 5;
        }

        #cannon::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 20px;
            width: 20px;
            height: 30px;
            background-color: #555;
            border-radius: 5px;
        }

        #controls {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 10px 0;
            margin-top: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        #controls button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        #controls button:hover {
            background-color: #0056b3;
        }

        /* Balloons - heart shape */
        .balloon {
            position: absolute;
            width: 30px;
            height: 30px;
            animation: fall linear forwards;
            opacity: 1;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            z-index: 2;
        }

        .balloon.popped {
            opacity: 0;
            transform: scale(0);
        }

        /* Improved Heart Shape */
        .balloon::before,
        .balloon::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: inherit;
            border-radius: 50%;
        }

        .balloon::before {
            left: -50%;
            top: 0; /* Changed to 0 to align with parent for better base */
            transform: translateY(-50%); /* Move up */
        }

        .balloon::after {
            left: 50%;
            top: 0; /* Changed to 0 */
            transform: translateY(-50%); /* Move up */
        }

        /* Combined main shape for the bottom V */
        .balloon {
            transform: rotate(-45deg); /* Rotate the main square to form the diamond */
            transform-origin: center center;
        }

        /* Specific balloon colors */
        .balloon.red { background-color: #ff0000; }
        .balloon.blue { background-color: #0000ff; }
        .balloon.green { background-color: #00ff00; }
        .balloon.yellow { background-color: #ffff00; }
        .balloon.purple { background-color: #800080; }

        /* Cannonball */
        .cannonball {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #fff;
            border-radius: 50%;
            z-index: 4;
            transition: transform linear;
        }

        /* Boss Specifics */
        #boss {
            position: absolute;
            top: 20px; /* Start near the top */
            width: 100px; /* Bigger size */
            height: 100px;
            background-color: #6a0dad; /* Purple for boss */
            border-radius: 10px;
            left: calc(50% - 50px);
            display: none; /* Hidden by default */
            z-index: 3;
            transition: left 0.5s ease-in-out; /* Smooth boss movement */
        }

        #boss-health-bar {
            position: absolute;
            bottom: -20px; /* Below the boss */
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #dc3545; /* Red for empty */
            border: 1px solid #000;
            box-sizing: border-box;
        }

        #boss-health-bar-fill {
            width: 100%;
            height: 100%;
            background-color: #28a745; /* Green for full */
            transition: width 0.2s ease-out;
        }

        .boss-projectile {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #ffc107; /* Orange/Yellow */
            border-radius: 50%;
            z-index: 6; /* Above cannonballs */
        }


        /* Animations */
        @keyframes fall {
            from { transform: translateY(-100px) rotate(-45deg); }
            to { transform: translateY(calc(100% + 50px)) rotate(-45deg); }
        }

        @keyframes fire-animation {
            0% { transform: scaleX(1); }
            50% { transform: scaleX(1.2); }
            100% { transform: scaleX(1); }
        }

        #cannon.firing::before {
            animation: fire-animation 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen" class="game-screen">
            <h1>Red Balloon Blaster - Evolved!</h1>
            <p>Enter your name:</p>
            <input type="text" id="playerNameInput" placeholder="Your Name">
            <button id="startButton">Start Game</button>
        </div>

        <div id="game-play-screen" class="game-screen hidden">
            <div id="game-info">
                <p>Player: <span id="playerNameDisplay"></span></p>
                <p>Score: <span id="scoreDisplay">0</span></p>
                <p>Lives: <span id="livesDisplay">3</span></p>
                <p>Level: <span id="levelDisplay">1</span></p>
            </div>
            <div id="game-area">
                <div id="cannon"></div>
            </div>
            <div id="controls">
                <button id="pauseButton">Pause</button>
            </div>
        </div>

        <div id="pause-screen" class="game-screen hidden">
            <h1>Game Paused</h1>
            <button id="continueButton">Continue</button>
            <button id="restartButtonPause">Restart</button>
        </div>

        <div id="level-complete-screen" class="game-screen hidden">
            <h1 id="levelCompleteMessage">Level 1 Complete!</h1>
            <p>Good job, <span id="levelCompletePlayerName"></span>!</p>
            <button id="nextLevelButton">Next Level</button>
        </div>

        <div id="game-over-screen" class="game-screen hidden">
            <h1>Game Over!</h1>
            <p id="finalScoreMessage">You scored <span id="finalScoreDisplay">0</span> points.</p>
            <button id="restartButtonGameOver">Restart</button>
        </div>
    </div>

    <script>
        /* --- JavaScript Logic --- */
        // --- Game State Variables ---
        let playerName = '';
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameRunning = false;
        let gamePaused = false;
        let gameLoopInterval;
        let balloonGenerationInterval;
        const activeGameObjects = []; // Array to hold active balloons, boss projectiles
        let isFiringContinuously = false;
        let fireRateInterval; // Interval for continuous firing
        let currentFireInterval = 200; // Initial fire interval in ms
        const MIN_FIRE_INTERVAL = 50; // Fastest fire rate possible

        // Boss variables
        let boss = null;
        let bossHealth = 0;
        let bossMaxHealth = 0;
        let bossFiringInterval;
        const BOSS_LEVEL = 3; // The level where the boss appears

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const gamePlayScreen = document.getElementById('game-play-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const gameOverScreen = document.getElementById('gameOver-screen');

        const playerNameInput = document.getElementById('playerNameInput');
        const startButton = document.getElementById('startButton');

        const playerNameDisplay = document.getElementById('playerNameDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const gameArea = document.getElementById('game-area');
        const cannon = document.getElementById('cannon');
        const pauseButton = document.getElementById('pauseButton');

        const continueButton = document.getElementById('continueButton');
        const restartButtonPause = document.getElementById('restartButtonPause');

        const levelCompleteMessage = document.getElementById('levelCompleteMessage');
        const levelCompletePlayerName = document.getElementById('levelCompletePlayerName');
        const nextLevelButton = document.getElementById('nextLevelButton');

        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButtonGameOver = document.getElementById('restartButtonGameOver');

        // --- Game Settings (Adjust for difficulty) ---
        const LEVEL_SETTINGS = {
            1: { balloonSpeed: 1.5, generationRate: 1500, balloonsToClear: 20, initialFireInterval: 200 },
            2: { balloonSpeed: 2.0, generationRate: 1200, balloonsToClear: 30, initialFireInterval: 180 },
            3: { // Boss Level
                balloonSpeed: 0, generationRate: 0, balloonsToClear: 1, // Cleared by defeating boss
                bossHealth: 200, bossSpeed: 1.5, bossFireRate: 1000, bossProjectileSpeed: 5
            },
            4: { balloonSpeed: 2.5, generationRate: 1000, balloonsToClear: 40, initialFireInterval: 160 },
            5: { balloonSpeed: 3.0, generationRate: 800, balloonsToClear: 50, initialFireInterval: 140 }
        };
        const BALLOON_SIZE = 30; // px
        const CANNONBALL_SPEED = 15; // Pixels per frame (increased for better feel)
        const SCORE_PER_OBJECT = 10;
        const BOSS_SHOT_DAMAGE = 10; // Damage one cannonball does to boss
        const MAX_LEVEL = 5;

        let objectsClearedInLevel = 0; // Tracks all objects shot down (balloons, boss)
        let totalObjectsGenerated = 0; // Tracks how many balloons have been generated this level

        // --- Utility Functions ---
        function showScreen(screenElement) {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.add('hidden');
            });
            screenElement.classList.remove('hidden');
        }

        function updateDisplay() {
            playerNameDisplay.textContent = playerName;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            levelDisplay.textContent = level;
        }

        function getRandomColor() {
            const colors = ['red', 'blue', 'green', 'yellow', 'purple'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // --- Game Logic Functions ---

        function startGame() {
            playerName = playerNameInput.value.trim();
            if (playerName === '') {
                alert('Please enter your name!');
                return;
            }
            score = 0;
            lives = 3;
            level = 1;
            objectsClearedInLevel = 0;
            totalObjectsGenerated = 0;
            activeGameObjects.length = 0; // Clear any existing objects
            gameArea.innerHTML = ''; // Clear existing elements
            gameArea.appendChild(cannon); // Re-add cannon
            cannon.style.left = `${gameArea.offsetWidth / 2 - cannon.offsetWidth / 2}px`; // Reset cannon position
            currentFireInterval = LEVEL_SETTINGS[1].initialFireInterval; // Reset fire rate

            showScreen(gamePlayScreen);
            gameRunning = true;
            gamePaused = false;
            updateDisplay();
            startLevel();
        }

        function startLevel() {
            objectsClearedInLevel = 0;
            totalObjectsGenerated = 0; // Reset for new level
            activeGameObjects.length = 0;
            gameArea.querySelectorAll('.balloon, .cannonball, .boss-projectile, #boss').forEach(el => el.remove());

            const currentSettings = LEVEL_SETTINGS[level];
            if (!currentSettings) {
                endGame(true); // Should not happen if all levels covered, acts as a win
                return;
            }

            clearInterval(balloonGenerationInterval);
            clearInterval(bossFiringInterval);
            if (boss) boss.remove(); // Remove boss if present from previous level
            boss = null;

            if (level === BOSS_LEVEL) {
                spawnBoss();
            } else {
                balloonGenerationInterval = setInterval(generateBalloon, currentSettings.generationRate);
            }

            if (gameLoopInterval) {
                cancelAnimationFrame(gameLoopInterval); // Stop previous loop if running
            }
            gameLoop(); // Start game loop for new level
        }

        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = true;
            showScreen(pauseScreen);
            clearInterval(balloonGenerationInterval);
            clearInterval(fireRateInterval); // Stop continuous fire
            clearInterval(bossFiringInterval); // Stop boss firing
            cancelAnimationFrame(gameLoopInterval);
        }

        function continueGame() {
            gamePaused = false;
            showScreen(gamePlayScreen);
            const currentSettings = LEVEL_SETTINGS[level];
            if (level === BOSS_LEVEL) {
                startBossFiring();
            } else {
                balloonGenerationInterval = setInterval(generateBalloon, currentSettings.generationRate);
            }
            if (isFiringContinuously) { // Resume continuous fire if it was active
                startContinuousFire();
            }
            gameLoop();
        }

        function restartGame() {
            clearInterval(balloonGenerationInterval);
            clearInterval(fireRateInterval);
            clearInterval(bossFiringInterval);
            cancelAnimationFrame(gameLoopInterval);
            startGame();
        }

        function endGame(win = false) {
            gameRunning = false;
            gamePaused = false;
            clearInterval(balloonGenerationInterval);
            clearInterval(fireRateInterval);
            clearInterval(bossFiringInterval);
            cancelAnimationFrame(gameLoopInterval);
            gameArea.innerHTML = '';
            gameArea.appendChild(cannon); // Ensure cannon is back for next game

            if (win) {
                if (level > MAX_LEVEL) {
                    levelCompleteMessage.textContent = "You Win! All Levels Complete!";
                    levelCompletePlayerName.textContent = playerName;
                    nextLevelButton.textContent = "Play Again!";
                    nextLevelButton.onclick = restartGame;
                } else {
                    levelCompleteMessage.textContent = `Level ${level} Complete!`;
                    levelCompletePlayerName.textContent = playerName;
                    nextLevelButton.textContent = "Next Level";
                    nextLevelButton.onclick = nextLevel;
                }
                showScreen(levelCompleteScreen);

            } else {
                finalScoreDisplay.textContent = score;
                showScreen(gameOverScreen);
            }
        }

        function generateBalloon() {
            if (!gameRunning || gamePaused || level === BOSS_LEVEL) return; // Don't generate balloons on boss level

            const balloon = document.createElement('div');
            const color = getRandomColor(); // Any color is targetable now
            balloon.className = `balloon ${color}`;
            balloon.dataset.color = color;
            balloon.dataset.type = 'balloon'; // New dataset for object type
            balloon.style.left = `${Math.random() * (gameArea.offsetWidth - BALLOON_SIZE)}px`;
            balloon.style.top = `-50px`;
            gameArea.appendChild(balloon);
            activeGameObjects.push(balloon);
            totalObjectsGenerated++;
        }

        function moveGameObjects() {
            const currentSettings = LEVEL_SETTINGS[level];
            for (let i = activeGameObjects.length - 1; i >= 0; i--) {
                const obj = activeGameObjects[i];

                if (obj.dataset.type === 'balloon') {
                    let currentTop = parseFloat(obj.style.top);
                    obj.style.top = `${currentTop + currentSettings.balloonSpeed}px`;

                    // Check if balloon went off screen (missed)
                    if (currentTop > gameArea.offsetHeight) {
                        if (!obj.dataset.popped) { // If not shot down
                            lives--;
                            updateDisplay();
                            if (lives <= 0) {
                                endGame();
                                return;
                            }
                        }
                        obj.remove();
                        activeGameObjects.splice(i, 1);
                    }
                } else if (obj.dataset.type === 'bossProjectile') {
                    let currentTop = parseFloat(obj.style.top);
                    obj.style.top = `${currentTop + currentSettings.bossProjectileSpeed}px`;

                    // Check collision with cannon
                    const cannonRect = cannon.getBoundingClientRect();
                    const projectileRect = obj.getBoundingClientRect();
                    const gameAreaRect = gameArea.getBoundingClientRect();

                    const cannonRelRect = {
                        left: cannonRect.left - gameAreaRect.left,
                        right: cannonRect.right - gameAreaRect.left,
                        top: cannonRect.top - gameAreaRect.top,
                        bottom: cannonRect.bottom - gameAreaRect.top
                    };
                    const projectileRelRect = {
                        left: projectileRect.left - gameAreaRect.left,
                        right: projectileRect.right - gameAreaRect.left,
                        top: projectileRect.top - gameAreaRect.top,
                        bottom: projectileRect.bottom - gameAreaRect.top
                    };

                    if (
                        projectileRelRect.left < cannonRelRect.right &&
                        projectileRelRect.right > cannonRelRect.left &&
                        projectileRelRect.top < cannonRelRect.bottom &&
                        projectileRelRect.bottom > cannonRelRect.top
                    ) {
                        // Collision with cannon!
                        lives--;
                        updateDisplay();
                        obj.remove();
                        activeGameObjects.splice(i, 1);
                        if (lives <= 0) {
                            endGame();
                            return;
                        }
                    }
                    // Remove if off screen
                    else if (currentTop > gameArea.offsetHeight) {
                        obj.remove();
                        activeGameObjects.splice(i, 1);
                    }
                }
            }
        }

        function moveCannonball(cannonball) {
            let currentBottom = parseFloat(cannonball.style.bottom);
            cannonball.style.bottom = `${currentBottom + CANNONBALL_SPEED}px`;

            // Check collision with game objects (balloons or boss)
            for (let i = activeGameObjects.length - 1; i >= 0; i--) {
                const obj = activeGameObjects[i];
                if (obj.dataset.popped || !gameArea.contains(obj)) continue; // Skip already popped or removed

                const objRect = obj.getBoundingClientRect();
                const cannonballRect = cannonball.getBoundingClientRect();

                if (
                    cannonballRect.left < objRect.right &&
                    cannonballRect.right > objRect.left &&
                    cannonballRect.top < objRect.bottom &&
                    cannonballRect.bottom > objRect.top
                ) {
                    // Collision!
                    cannonball.remove(); // Remove cannonball

                    if (obj.dataset.type === 'balloon') {
                        score += SCORE_PER_OBJECT;
                        objectsClearedInLevel++;
                        obj.classList.add('popped');
                        obj.dataset.popped = 'true';
                        setTimeout(() => {
                            if (gameArea.contains(obj)) {
                                obj.remove();
                                // Remove from activeGameObjects array
                                const objIndex = activeGameObjects.indexOf(obj);
                                if (objIndex > -1) {
                                    activeGameObjects.splice(objIndex, 1);
                                }
                            }
                        }, 200);
                    } else if (obj.id === 'boss') {
                        bossHealth -= BOSS_SHOT_DAMAGE;
                        updateBossHealthBar();
                        if (bossHealth <= 0) {
                            score += 500; // Bonus points for boss kill
                            objectsClearedInLevel++; // Count boss as one cleared object
                            boss.remove();
                            clearInterval(bossFiringInterval);
                            boss = null;
                            activeGameObjects.splice(activeGameObjects.indexOf(obj), 1); // Remove boss from array
                            checkLevelCompletion(); // Boss defeated, check level
                        }
                    }
                    updateDisplay();
                    checkLevelCompletion(); // Check if balloon cleared advances level
                    return; // Cannonball hit an object, stop checking for this cannonball
                }
            }

            // Remove cannonball if it goes off screen
            if (currentBottom < 0) { // Cannonballs go up, so check top
                cannonball.remove();
            }
        }


        function fireCannon() {
            if (!gameRunning || gamePaused) return;

            cannon.classList.add('firing');
            setTimeout(() => cannon.classList.remove('firing'), 100);

            const cannonball = document.createElement('div');
            cannonball.className = 'cannonball';
            cannonball.style.left = `${cannon.offsetLeft + cannon.offsetWidth / 2 - 5}px`;
            cannonball.style.bottom = `${cannon.offsetHeight - 5}px`;
            gameArea.appendChild(cannonball);
            // Cannonballs are not added to activeGameObjects as they are temporary and only move upwards
        }

        // --- Continuous Fire Logic ---
        function startContinuousFire() {
            if (isFiringContinuously) return; // Prevent multiple intervals
            isFiringContinuously = true;
            fireCannon(); // Fire immediately on hold
            fireRateInterval = setInterval(fireCannon, currentFireInterval);
        }

        function stopContinuousFire() {
            isFiringContinuously = false;
            clearInterval(fireRateInterval);
        }

        function increaseFireRate() {
            // This could be tied to score or a separate "fire power" metric
            // For now, let's tie it to every X points
            // Example: Increase fire rate every 100 points
            const newFireInterval = LEVEL_SETTINGS[level].initialFireInterval - Math.floor(score / 100) * 10;
            currentFireInterval = Math.max(newFireInterval, MIN_FIRE_INTERVAL);

            if (isFiringContinuously) {
                stopContinuousFire();
                startContinuousFire(); // Restart interval with new rate
            }
        }


        function checkLevelCompletion() {
            const currentSettings = LEVEL_SETTINGS[level];
            if (level === BOSS_LEVEL) {
                // For boss level, completion is when boss is defeated
                if (boss === null) { // Boss is removed when defeated
                    advanceLevelOrWin();
                }
            } else if (objectsClearedInLevel >= currentSettings.balloonsToClear) {
                // For regular levels, clear target number of objects
                advanceLevelOrWin();
            }
        }

        function advanceLevelOrWin() {
            gameRunning = false;
            clearInterval(balloonGenerationInterval);
            clearInterval(bossFiringInterval);
            cancelAnimationFrame(gameLoopInterval);

            if (level < MAX_LEVEL) {
                showScreen(levelCompleteScreen);
            } else {
                endGame(true); // All levels completed, you win!
            }
        }

        function nextLevel() {
            level++;
            if (level > MAX_LEVEL) { // Should be caught by checkLevelCompletion, but good fallback
                endGame(true);
                return;
            }
            showScreen(gamePlayScreen);
            gameRunning = true;
            gamePaused = false;
            updateDisplay();
            startLevel();
        }

        // --- Boss Logic ---
        function spawnBoss() {
            boss = document.createElement('div');
            boss.id = 'boss';
            boss.style.display = 'block'; // Make visible

            const healthBar = document.createElement('div');
            healthBar.id = 'boss-health-bar';
            const healthFill = document.createElement('div');
            healthFill.id = 'boss-health-bar-fill';
            healthBar.appendChild(healthFill);
            boss.appendChild(healthBar);

            gameArea.appendChild(boss);
            activeGameObjects.push(boss); // Add boss to active game objects

            const currentSettings = LEVEL_SETTINGS[BOSS_LEVEL];
            bossMaxHealth = currentSettings.bossHealth;
            bossHealth = bossMaxHealth;
            updateBossHealthBar();

            // Initial boss position
            boss.style.left = `${Math.random() * (gameArea.offsetWidth - boss.offsetWidth)}px`;

            startBossFiring();
            moveBoss(); // Start moving the boss
        }

        function updateBossHealthBar() {
            if (boss) {
                const healthFill = document.getElementById('boss-health-bar-fill');
                const percentage = (bossHealth / bossMaxHealth) * 100;
                healthFill.style.width = `${Math.max(0, percentage)}%`;
            }
        }

        function startBossFiring() {
            const currentSettings = LEVEL_SETTINGS[BOSS_LEVEL];
            clearInterval(bossFiringInterval);
            bossFiringInterval = setInterval(fireBossProjectile, currentSettings.bossFireRate);
        }

        function fireBossProjectile() {
            if (!gameRunning || gamePaused || !boss) return;

            const projectile = document.createElement('div');
            projectile.className = 'boss-projectile';
            projectile.dataset.type = 'bossProjectile';

            // Position projectile from the boss's center
            projectile.style.left = `${boss.offsetLeft + boss.offsetWidth / 2 - 7.5}px`;
            projectile.style.top = `${boss.offsetTop + boss.offsetHeight}px`; // Below boss

            gameArea.appendChild(projectile);
            activeGameObjects.push(projectile);
        }

        function moveBoss() {
            if (!gameRunning || gamePaused || !boss) return;

            const currentSettings = LEVEL_SETTINGS[BOSS_LEVEL];
            // Boss moves randomly horizontally
            let targetX = Math.random() * (gameArea.offsetWidth - boss.offsetWidth);
            boss.style.left = `${targetX}px`;

            // Adjust movement speed / frequency if needed for difficulty
            setTimeout(moveBoss, 2000); // Move boss every 2 seconds randomly
        }


        // --- Game Loop (requestAnimationFrame for smooth animations) ---
        function gameLoop() {
            if (!gameRunning || gamePaused) return;

            moveGameObjects(); // Move balloons and boss projectiles

            // Move all active cannonballs
            gameArea.querySelectorAll('.cannonball').forEach(cb => {
                moveCannonball(cb);
            });

            gameLoopInterval = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---

        // Start Screen
        startButton.addEventListener('click', startGame);
        playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') startGame();
        });

        // Game Play Screen - Tap/Hold to Fire & Cannon Drag
        let isDraggingCannon = false;
        let initialCannonX;
        let initialClientX;

        // Mouse/Touch Down on game area (for firing and initiating drag)
        gameArea.addEventListener('mousedown', (e) => {
            if (!gameRunning || gamePaused) return;

            // If click is on cannon, initiate drag
            if (e.target === cannon || cannon.contains(e.target)) {
                isDraggingCannon = true;
                cannon.style.cursor = 'grabbing';
                initialCannonX = cannon.offsetLeft;
                initialClientX = e.clientX;
            } else { // Otherwise, fire
                startContinuousFire();
            }
        });

        gameArea.addEventListener('touchstart', (e) => {
            if (!gameRunning || gamePaused || e.touches.length === 0) return;
            e.preventDefault(); // Prevent default browser touch actions (scrolling, zooming)

            // If touch starts on cannon, initiate drag
            if (e.target === cannon || cannon.contains(e.target)) {
                isDraggingCannon = true;
                initialCannonX = cannon.offsetLeft;
                initialClientX = e.touches[0].clientX;
            } else { // Otherwise, fire
                startContinuousFire();
            }
        }, { passive: false });


        // Mouse/Touch Move on the entire gameArea to allow drag
        gameArea.addEventListener('mousemove', (e) => {
            if (isDraggingCannon && gameRunning && !gamePaused) {
                const dx = e.clientX - initialClientX;
                let newX = initialCannonX + dx;

                // Constrain cannon to game area boundaries
                if (newX < 0) newX = 0;
                if (newX > gameArea.offsetWidth - cannon.offsetWidth) newX = gameArea.offsetWidth - cannon.offsetWidth;
                cannon.style.left = `${newX}px`;
            }
        });

        gameArea.addEventListener('touchmove', (e) => {
            if (isDraggingCannon && gameRunning && !gamePaused && e.touches.length > 0) {
                e.preventDefault(); // Prevent default browser touch actions (scrolling)
                const dx = e.touches[0].clientX - initialClientX;
                let newX = initialCannonX + dx;

                if (newX < 0) newX = 0;
                if (newX > gameArea.offsetWidth - cannon.offsetWidth) newX = gameArea.offsetWidth - cannon.offsetWidth;
                cannon.style.left = `${newX}px`;
            }
        }, { passive: false });

        // Mouse/Touch Up to stop continuous fire and drag
        document.addEventListener('mouseup', () => {
            isDraggingCannon = false;
            cannon.style.cursor = 'grab';
            stopContinuousFire();
        });

        document.addEventListener('touchend', () => {
            isDraggingCannon = false;
            stopContinuousFire();
        });

        // Pause Button
        pauseButton.addEventListener('click', pauseGame);

        // Pause Screen
        continueButton.addEventListener('click', continueGame);
        restartButtonPause.addEventListener('click', restartGame);

        // Level Complete Screen
        nextLevelButton.addEventListener('click', nextLevel);

        // Game Over Screen
        restartButtonGameOver.addEventListener('click', restartGame);

        // Initial setup
        showScreen(startScreen);
        updateDisplay();
    </script>
</body>
</html>
